package com.example.assignment1bscaffold;

import java.util.ArrayList;
import java.util.List;

/**
 * This submission is Rishikumar Patel's original work and has not been copied
 * or generated by a bot.
 * I have read the rules about academic freedom and understand that an academic
 * violation is not only
 * a blemish on my school record, but has implications for myself, my
 * classmates, Conestoga College,
 * and society in general.
 */
public class Assignment1aAssignment {

    private Assignment1aAssignment() {
    };

    /**
     * Rotates the elements of a string array to the left by a specified number of
     * places.
     *
     * @param stringArray array of strings to rotate
     * @param places      number of places to rotate the array to the left
     * @return a new array with the elements rotated to the left by the specified
     *         number of places
     */
    public static String[] rotateArray(String[] stringArray, int places) {
        if (stringArray == null || stringArray.length == 0 || places % stringArray.length == 0) {
            return stringArray;
        }
        int n = stringArray.length;
        String[] rotatedArray = new String[n];
        for (int i = 0; i < n; i++) {
            rotatedArray[i] = stringArray[(i + places) % n];
        }
        return rotatedArray;
    }

    /**
     * Inserts a page break string ("*page break*") after every nth element in the
     * input array.
     *
     * @param sentences the array of strings to process
     * @param location  the interval at which to insert the page break
     * @return a new array with the page break string inserted at every nth location
     */
    public static String[] insertPageBreaks(String[] sentences, int location) {
        if (sentences == null || sentences.length == 0 || location > sentences.length) {
            return sentences;
        }
        List<String> listWithBreaks = new ArrayList<>();
        for (int i = 0; i < sentences.length; i++) {
            listWithBreaks.add(sentences[i]);
            if ((i + 1) % location == 0 && i != sentences.length - 1) {
                listWithBreaks.add("*page break*");
            }
        }
        return listWithBreaks.toArray(new String[0]);
    }

    /**
     * Solves the logic puzzle to determine which student owns which pet.
     *
     * @return a 2D array with the first row containing student names and the second
     *         row containing their corresponding pets
     */
    public static String[][] solveLogicPuzzle() {
        String[] names = { "Bob", "Jane", "Priya", "Lane", "Yien" };
        String[] pets = { "dog", "cat", "bird", "fish", "hamster" };
        String[] ownerPetMatch = new String[5];

        // Initial clue: Bob has a dog
        ownerPetMatch[0] = "dog";

        // Boolean array tracking possible pets for each student
        boolean[][] possiblePets = {
                { true, false, false, false, false },
                { true, false, true, false, true },
                { true, false, false, true, false },
                { false, false, true, true, true },
                { false, true, false, true, false }
        };

        // Applying given constraints
        possiblePets[2][4] = false; // Priya doesn't have hamster
        possiblePets[2][3] = false; // Priya doesn't have fish
        possiblePets[1][2] = false; // Jane doesn't have bird
        possiblePets[2][2] = false; // Priya doesn't have bird
        possiblePets[3][0] = false; // Lane doesn't have dog
        possiblePets[3][1] = false; // Lane doesn't have cat
        possiblePets[3][4] = false; // Lane doesn't have hamster
        possiblePets[4][0] = false; // Yien doesn't have dog
        possiblePets[4][2] = false; // Yien doesn't have bird
        possiblePets[4][4] = false; // Yien doesn't have hamster
        possiblePets[1][1] = false; // Jane doesn't have cat

        // Elimination logic to determine pet ownership
        for (int i = 0; i < 5; i++) {
            if (i != 0) {
                for (int j = 0; j < 5; j++) {
                    if (possiblePets[i][j] && isSingleTrueInColumn(possiblePets, j)) {
                        ownerPetMatch[i] = pets[j];
                        for (int k = 0; k < 5; k++) {
                            possiblePets[k][j] = false;
                        }
                    }
                }
            }
        }

        // Assign remaining pets based on elimination results
        for (int j = 0; j < 5; j++) {
            if (possiblePets[1][j])
                ownerPetMatch[1] = pets[j]; // Jane
            if (possiblePets[2][j])
                ownerPetMatch[2] = pets[j]; // Priya
            if (possiblePets[3][j])
                ownerPetMatch[3] = pets[j]; // Lane
            if (possiblePets[4][j])
                ownerPetMatch[4] = pets[j]; // Yien
        }

        return new String[][] { names, ownerPetMatch };
    }

    /**
     * Helper function to check if a column has only one true value.
     *
     * @param matrix the boolean matrix to check
     * @param col    the column index to check
     * @return true if the column has only one true value, false otherwise
     */
    private static boolean isSingleTrueInColumn(boolean[][] matrix, int col) {
        int trueCount = 0;
        for (boolean[] row : matrix) {
            if (row[col])
                trueCount++;
        }
        return trueCount == 1;
    }

    /**
     * Calculates coordinates for players arranged around a circular table.
     *
     * @param diameter the diameter of the circle
     * @param players  the number of players to position around the table
     * @return a 2D array containing the x and y coordinates of each player
     */
    public static double[][] locatePlayers(int diameter, int players) {
        double[][] coordinates = new double[players][2];
        double radius = (diameter - 40) / 2.0;
        double centerX = radius + 20;
        double centerY = radius + 20;

        for (int i = 0; i < players; i++) {
            double angle = 2 * Math.PI * i / players;
            coordinates[i][0] = centerX + radius * Math.cos(angle - Math.PI / 2);
            coordinates[i][1] = centerY + radius * Math.sin(angle - Math.PI / 2);
        }

        return coordinates;
    }
}
