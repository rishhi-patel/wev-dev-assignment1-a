package com.example.assignment1bscaffold;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * This submission is Gowri karthik sammeta's original work and has not been
 * copied or
 * generated by a bot. I have read the rules about academic freedom and
 * understand that an academic
 * violation is not only a blemish
 * on my school record, but has implications for myself, my classmates,
 * Conestoga College and society in
 * general.
 */
public class Assignment1aAssignment {

    // Prevent instantiation of the utility class
    private Assignment1aAssignment() {

    }

    /**
     * rotates the elements of an array to the left by a specified
     * number.
     *
     * @param data  The array of strings to be rotated
     * @param shift The number of positions to shift the array
     * @return The rotated string array
     */
    public static String[] rotateLeft(String[] data, int shift) {
        if (data == null || data.length == 0 || shift % data.length == 0) {
            return data;
        }
        int len = data.length;
        String[] result = new String[len];
        shift = shift % len;
        for (int i = 0; i < len; i++) {
            int newIndex = (i + len - shift) % len;
            result[newIndex] = data[i];
        }
        return result;
    }

    /**
     * Inserts a special string at specific intervals in an array of strings.
     *
     * @param text     Array of strings
     * @param interval Interval at which to insert the special string
     * @return Modified array with inserted strings
     */
    public static String[] insertBreaks(String[] text, int interval) {
        if (text == null || text.length == 0 || interval <= 0 || interval > text.length) {
            return text;
        }
        List<String> modifiedText = new ArrayList<>();
        for (int i = 0; i < text.length; i++) {
            modifiedText.add(text[i]);
            if ((i + 1) % interval == 0 && i < text.length - 1) {
                modifiedText.add("*page break*");
            }
        }
        return modifiedText.toArray(new String[0]);
    }

    /**
     * Solves the logic puzzle to determine which student owns which pet.
     *
     * @return a 2D array with the first row containing student names and the second
     *         row containing their corresponding pets
     */
    public static String[][] solveLogicPuzzle() {
        String[] students = { "Bob", "Jane", "Priya", "Lane", "Yien" };
        String[] pets = assignPetsToStudents(students);
        String[][] solution = new String[students.length][2];
        for (int i = 0; i < students.length; i++) {
            solution[i][0] = students[i];
            solution[i][1] = pets[i];
        }
        return solution;
    }

    /**
     * This helper function assigns pets to students based on predefined rules.
     * Assuming specific preferences and availability can be resolved in a linear
     * order.
     */
    private static String[] assignPetsToStudents(String[] students) {
        Map<String, String> preference = new HashMap<>();
        preference.put("Bob", "dog");
        preference.put("Lane", "bird");
        preference.put("Priya", "cat");
        preference.put("Jane", "hamster");
        preference.put("Yien", "fish");

        String[] pets = new String[students.length];
        for (int i = 0; i < students.length; i++) {
            pets[i] = preference.get(students[i]);
        }
        return pets;
    }

    /**
     * Determines the positions of players seated around a circular table.
     *
     * @param diameter    Diameter of the circle
     * @param playerCount Number of players
     * @return Coordinates of each player around the table
     */
    public static List<String> calculatePlayerPositions(int diameter, int playerCount) {
        List<String> positions = new ArrayList<>();
        double radius = diameter / 2.0;
        double centerX = radius + 20; // Includes margin for clarity
        double centerY = radius + 20;

        for (int i = 0; i < playerCount; i++) {
            double angle = Math.PI / 2 - i * 2 * Math.PI / playerCount;
            int x = (int) (centerX + radius * Math.cos(angle));
            int y = (int) (centerY - radius * Math.sin(angle));
            positions.add(String.format("Player %d: (%d, %d)", i + 1, x, y));
        }

        return positions;
    }
}
