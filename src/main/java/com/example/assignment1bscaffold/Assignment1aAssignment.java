package com.example.assignment1bscaffold;

import java.util.ArrayList;
import java.util.List;

/**
 * This submission is Rishikumar Patel's original work and has not been copied
 * or generated by a bot.
 * I have read the rules about academic freedom and understand that an academic
 * violation is not only
 * a blemish on my school record, but has implications for myself, my
 * classmates, Conestoga College,
 * and society in general.
 */
public class Assignment1aAssignment {

    private Assignment1aAssignment() {
    };

    /**
     * Rotates the elements of a string array to the left by a specified number of
     * places.
     *
     * @param stringArray array of strings to rotate
     * @param places      number of places to rotate the array to the left
     * @return a new array with the elements rotated to the left by the specified
     *         number of places
     */
    public static String[] rotateArray(String[] stringArray, int places) {
        if (stringArray == null || stringArray.length == 0 || places % stringArray.length == 0) {
            return stringArray;
        }
        int n = stringArray.length;
        String[] rotatedArray = new String[n];
        for (int i = 0; i < n; i++) {
            rotatedArray[i] = stringArray[(i + places) % n];
        }
        return rotatedArray;
    }

    /**
     * Inserts a page break string ("*page break*") after every nth element in the
     * input array.
     *
     * @param sentences the array of strings to process
     * @param location  the interval at which to insert the page break
     * @return a new array with the page break string inserted at every nth location
     */
    public static String[] insertPageBreaks(String[] sentences, int location) {
        if (sentences == null || sentences.length == 0 || location > sentences.length) {
            return sentences;
        }
        List<String> listWithBreaks = new ArrayList<>();
        for (int i = 0; i < sentences.length; i++) {
            listWithBreaks.add(sentences[i]);
            if ((i + 1) % location == 0 && i != sentences.length - 1) {
                listWithBreaks.add("*page break*");
            }
        }
        return listWithBreaks.toArray(new String[0]);
    }

    /**
     * Solves the logic puzzle to determine which student owns which pet.
     *
     * @return a 2D array with the first row containing student names and the second
     *         row containing their corresponding pets
     */
    public static String[][] solveLogicPuzzle() {
        // Initialize the results array
        String[][] solution = new String[5][2];

        // Assigning pets based on direct clues and logical deduction
        solution[0][0] = "Bob"; // Bob
        solution[0][1] = "dog"; // has a dog

        solution[3][0] = "Lane"; // Lane
        solution[3][1] = "bird"; // has a bird (not furry, and only bird or fish are left, not taken by Priya or
                                 // Jane)

        solution[4][0] = "Yien"; // Yien
        solution[4][1] = "fish"; // has a fish (not a cat, since Priya has it)

        solution[2][0] = "Priya"; // Priya
        solution[2][1] = "cat"; // has a cat (can't have fish or hamster, and bird is taken)

        solution[1][0] = "Jane"; // Jane
        solution[1][1] = "hamster"; // has a hamster (left option, can't have cat or bird)

        return solution;
    }

    /**
     * Helper function to check if a column has only one true value.
     *
     * @param matrix the boolean matrix to check
     * @param col    the column index to check
     * @return true if the column has only one true value, false otherwise
     */
    private static boolean isSingleTrueInColumn(boolean[][] matrix, int col) {
        int trueCount = 0;
        for (boolean[] row : matrix) {
            if (row[col])
                trueCount++;
        }
        return trueCount == 1;
    }

    /**
     * Calculates coordinates for players arranged around a circular table.
     *
     * @param diameter the diameter of the circle
     * @param players  the number of players to position around the table
     * @return a 2D array containing the x and y coordinates of each player
     */
    public static double[][] locatePlayers(int diameter, int players) {
        double[][] coordinates = new double[players][2];
        double radius = (diameter - 40) / 2.0;
        double centerX = radius + 20;
        double centerY = radius + 20;

        for (int i = 0; i < players; i++) {
            double angle = 2 * Math.PI * i / players;
            coordinates[i][0] = centerX + radius * Math.cos(angle - Math.PI / 2);
            coordinates[i][1] = centerY + radius * Math.sin(angle - Math.PI / 2);
        }

        return coordinates;
    }
}
