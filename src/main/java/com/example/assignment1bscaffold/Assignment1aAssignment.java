package com.example.assignment1bscaffold;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * This submission is Rishikumar Patel's original work and has not been copied
 * or generated by a bot.
 * I have read the rules about academic freedom and understand that an academic
 * violation is not only
 * a blemish on my school record, but has implications for myself, my
 * classmates, Conestoga College,
 * and society in general.
 */
public class Assignment1aAssignment {

    private Assignment1aAssignment() {
    };

    /**
     * Rotates the elements of a string array to the left by a specified number of
     * places.
     *
     * @param stringArray array of strings to rotate
     * @param places      number of places to rotate the array to the left
     * @return a new array with the elements rotated to the left by the specified
     *         number of places
     */
    public static String[] rotateArray(String[] stringArray, int places) {
        if (stringArray == null || stringArray.length == 0 || places % stringArray.length == 0) {
            return stringArray;
        }
        int n = stringArray.length;
        String[] rotatedArray = new String[n];
        for (int i = 0; i < n; i++) {
            rotatedArray[i] = stringArray[(i + places) % n];
        }
        return rotatedArray;
    }

    /**
     * Inserts a page break string ("*page break*") after every nth element in the
     * input array.
     *
     * @param sentences the array of strings to process
     * @param location  the interval at which to insert the page break
     * @return a new array with the page break string inserted at every nth location
     */
    public static String[] insertPageBreaks(String[] sentences, int location) {
        if (sentences == null || sentences.length == 0 || location > sentences.length) {
            return sentences;
        }
        List<String> listWithBreaks = new ArrayList<>();
        for (int i = 0; i < sentences.length; i++) {
            listWithBreaks.add(sentences[i]);
            if ((i + 1) % location == 0 && i != sentences.length - 1) {
                listWithBreaks.add("*page break*");
            }
        }
        return listWithBreaks.toArray(new String[0]);
    }

    /**
     * Solves the logic puzzle to determine which student owns which pet.
     *
     * @return a 2D array with the first row containing student names and the second
     *         row containing their corresponding pets
     */

    public static String[][] solveLogicPuzzle() {
        String[] students = { "Bob", "Jane", "Priya", "Lane", "Yien" };
        String[] pets = { "dog", "cat", "bird", "fish", "hamster" };
        Map<String, String> assignments = new HashMap<>();

        if (solve(0, students, pets, assignments)) {
            String[][] solution = new String[students.length][2];
            for (int i = 0; i < students.length; i++) {
                solution[i][0] = students[i];
                solution[i][1] = assignments.get(students[i]);
            }
            return solution;
        } else {
            return null;
        }
    }

    private static boolean solve(int index, String[] students, String[] pets, Map<String, String> assignments) {
        if (index == students.length) {
            return true;
        }

        String student = students[index];
        for (String pet : pets) {
            if (canAssign(student, pet, assignments)) {
                assignments.put(student, pet);
                if (solve(index + 1, students, pets, assignments)) {
                    return true;
                }
                assignments.remove(student);
            }
        }
        return false;
    }

    private static boolean canAssign(String student, String pet, Map<String, String> assignments) {
        if (assignments.containsValue(pet)) {
            return false; // Pet is already assigned
        }

        switch (student) {
            case "Bob":
                return pet.equals("dog");
            case "Priya":
                return !pet.equals("hamster") && !pet.equals("fish");
            case "Jane":
                return !pet.equals("cat") && !pet.equals("bird");
            case "Lane":
                return !pet.equals("cat") && !pet.equals("dog") && !pet.equals("hamster");
            case "Yien":
                return pet.equals("cat") || pet.equals("fish");
        }

        return true; // If no specific constraint contradicts it
    }

    /**
     * Calculates coordinates for players arranged around a circular table.
     *
     * @param diameter the diameter of the circle
     * @param players  the number of players to position around the table
     * @return a 2D array containing the x and y coordinates of each player
     */
    public static List<String> aroundTheTable(int diameter, int players) {
        int radius = diameter / 2;
        List<String> coordinates = new ArrayList<>();

        // Constants for canvas placement
        int xOffset = 20 + radius;
        int yOffset = 20 + radius;

        // Calculate the angle step in radians
        double angleStep = 2 * Math.PI / players;

        // Generate coordinates for each player
        for (int i = 0; i < players; i++) {
            double angle = angleStep * i - Math.PI / 2; // Offset by PI/2 to start at the bottom
            int x = (int) (xOffset + radius * Math.cos(angle));
            int y = (int) (yOffset + radius * Math.sin(angle));
            coordinates.add(String.format("Player %d: (%d, %d)", i + 1, x, y));
        }

        return coordinates;
    }
}
